#ex1-hello-jpa
JPA의 데이터 타입 분류
 · 엔티티 타입
  - @Entity로 정의하는 객체
  - 데이터가 변해도 식별자로 지속해서 '추적 가능'
  - 예)회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능
 · 값 타입
  - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
  - 식별자가 없고 값만 있으므로 변경 시 추적 불가
  - 예)숫자 100을 200으로 변경하면 완전히 다른 값으로 대체
기본값 타입
 · 생명주기를 엔티티의 의존
 · 값 타입은 공유하면 X
 
참고 : 자바의 기본 타입은 절대 공유 X
 · Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경 X

임베디드 타입
 · 새로운 값 타입을 직접 정의할 수 있음
 · JPA는 임베디드 타입이라 함
 · 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함
 · int, String과 같은 값 타입
임베디드 타입과 테이블 매핑
 · 임베디드 타입은 엔티티의 값일 뿐이다
 · 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다
 · 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능
 · 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음

값 타입과 불변 객체
값 타입 공유 참조
 · 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함
 · side effect 발생
 
기본 타입(primitive type)
itn a = 10;
int b = a; //기본 타입은 값을 복사
b = 4;
객체 타입
Address a = new Address("Old");
Address b = a; //객체 타입은 참조를 전달
b.setCity("New")

불변 객체
 · 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단
 · 값 타입은 불변 객체로 설계해야함
 · 불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체
 · 생성자로만 값을 설정하고 Setter를 만들지 않으면 됨
 · 참고 : Integer,String은 자바가 제공하는 대표적인 불변 객체

값 타입의 비교
 · 인스턴드가 달라도 그 안에 값이 같으면 같은 것으로 봐야 함
 · 동일성(identity) 비교 : 인스턴스의 참조 값을 비교, == 사용
 · 동등성(equibalence) 비교 : 인스턴스의 값을 비교, euqlas() 사용

값 타입 컬렉션
 · 값 타입을 하나 이상 저장할 때 사용
 ·  @ElementCollection, @CollectionTable 사용
 · DB는 컬렉션을 같은 테이블에 저장할 수 없다
 · 컬렉션을 저장하기 위한 별도의 테이블이 필요함
값 타입 컬렉션 사용
 · 값 타입 컬렉션도 지연 로딩 전략 사용
값 타입 컬렉션의 제약사항
 · 값 타입은 엔티티와 다르게 식별자 개념이 없다
 · 값은 변경하면 추적이 어렵다
 · 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다
값 타입 컬렉션 대안
 · 실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려
 · 일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용
 


  
 

 